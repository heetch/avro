
// Code generated by avrogen. DO NOT EDIT.

package dummy

import (
 "fmt"
 "github.com/heetch/avro/avrotypegen"
 "strconv"
)


	
	type Child2 int
		const (
		Child2UNSPECIFIED Child2 = iota
		Child2STARTED
		Child2COMPLETED
		Child2FAILED
		Child2ADDED_BY_OPERATOR
		)

		var _Child2_strings = []string{
		"UNSPECIFIED",
		"STARTED",
		"COMPLETED",
		"FAILED",
		"ADDED_BY_OPERATOR",
		}

		// String returns the textual representation of Child2.
		func (e Child2) String() string {
			if e < 0 || int(e) >= len(_Child2_strings) {
				return "Child2(" + strconv.FormatInt(int64(e), 10) + ")"
			}
			return _Child2_strings[e]
		}

		// MarshalText implements encoding.TextMarshaler
		// by returning the textual representation of Child2.
		func (e Child2) MarshalText() ([]byte, error) {
			if e < 0 || int(e) >= len(_Child2_strings) {
				return nil, fmt.Errorf("Child2 value %d is out of bounds", e)
			}
			return []byte(_Child2_strings[e]), nil
		}

		// UnmarshalText implements encoding.TextUnmarshaler
		// by expecting the textual representation of Child2.
		func (e *Child2) UnmarshalText(data []byte) error {
			// Note for future: this could be more efficient.
			for i, s := range _Child2_strings {
				if string(data) == s {
					*e = Child2(i)
					return nil
				}
			}
			return fmt.Errorf("unknown value %q for Child2", data)
		}
	
	

	
	
		type Object struct {
	// Child1
Child1 Child1
		Child2 Child2
		
		}

		// AvroRecord implements the avro.AvroRecord interface.
		func (Object) AvroRecord() avrotypegen.RecordInfo {
			return avrotypegen.RecordInfo{
Schema: `{"fields":[{"doc":"Child1","name":"Child1","type":{"default":"UNSPECIFIED","doc":"doc","heetchmeta":{"skipRFC":true},"name":"Child1","namespace":"subns","symbols":["UNSPECIFIED","VALUE1","VALUE2","VALUE_EXTRA_1","VALUE_EXTRA_2"],"type":"enum"}},{"default":"UNSPECIFIED","name":"Child2","type":{"name":"Child2","symbols":["UNSPECIFIED","STARTED","COMPLETED","FAILED","ADDED_BY_OPERATOR"],"type":"enum"}}],"heetchmeta":{"version":1},"name":"ns.Object","type":"record"}`,
Required: []bool{
0: true,
},
}
		}
	
	

	
	
// doc
type Child1 int
		const (
		Child1UNSPECIFIED Child1 = iota
		Child1VALUE1
		Child1VALUE2
		Child1VALUE_EXTRA_1
		Child1VALUE_EXTRA_2
		)

		var _Child1_strings = []string{
		"UNSPECIFIED",
		"VALUE1",
		"VALUE2",
		"VALUE_EXTRA_1",
		"VALUE_EXTRA_2",
		}

		// String returns the textual representation of Child1.
		func (e Child1) String() string {
			if e < 0 || int(e) >= len(_Child1_strings) {
				return "Child1(" + strconv.FormatInt(int64(e), 10) + ")"
			}
			return _Child1_strings[e]
		}

		// MarshalText implements encoding.TextMarshaler
		// by returning the textual representation of Child1.
		func (e Child1) MarshalText() ([]byte, error) {
			if e < 0 || int(e) >= len(_Child1_strings) {
				return nil, fmt.Errorf("Child1 value %d is out of bounds", e)
			}
			return []byte(_Child1_strings[e]), nil
		}

		// UnmarshalText implements encoding.TextUnmarshaler
		// by expecting the textual representation of Child1.
		func (e *Child1) UnmarshalText(data []byte) error {
			// Note for future: this could be more efficient.
			for i, s := range _Child1_strings {
				if string(data) == s {
					*e = Child1(i)
					return nil
				}
			}
			return fmt.Errorf("unknown value %q for Child1", data)
		}
	
	

